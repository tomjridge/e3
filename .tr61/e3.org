
  - need to try an array impl (although previous testing indicated
    this performed as hashtables)


  - need to start counting operations, sizes of datastructures etc to
    determine where the performance can be improved


* 2015-12-25 

  - map/set types
    - functorize, or parameterize? these can't be see from the
      outside; but they do depend on an ordering; so keep types
      abstract... but the ordering is an essential part of having the
      type; but maybe this is only done at initialization time; so we
      need a way of saying (when instantiating the fixed but abstract
      types) that this operation belongs to this type, even though we
      are ultimately going to assert the type is equal to some other
      type

* 2015-12-28 different languages

  - substring
  - symbol
    - CA sym_case
    - DC sym_of_tm
  - item
    - DC mk_tm_coord
    - PR tm5
    - DC mk_sym_Coord
    - PR sym6
    - PR nt2
    -    shift
    - PR b2_nil
    - PR a2
    - PR hd_b2
    - DC mk_item
    - CA dest_item
    - PR tm_dot_i9
    - PR sym_dot_i9
    - PR sym_dot_j9
    - PR nt_dot_i9
    - PR nt_dot_j9
    -    with_j9


  - grammar
  - substring+symbol+item
    - nt_items_for_nt 
  - substring + symbol (but really this is to a "completed tm_item")
    - p_of_tm


  - input
    - string,length


---

order of fixing things:



                                                    
                                                    
                                                    
                                                    
#+BEGIN_SRC                                                    
                               
              string-------+-----+
               v           |     v
              substring    |   input(string,length)
                           |   
                           |
                           |
    symbol                 |
     v                     |
    item-------------------+
     v                     v
    sets,maps            grammar
                                                    

#+END_SRC                                                    
                                                    
                                                    
                                                    
                                                    

---

we want the string type to be polymorphic, and hence also the grammar
and the input; this argues for making these parameters of a record
(ctxt)

the impl of substring can be hidden

the impl of symbol is another parameter, but typically this is at a
different level; these can typically be parameterized using functors,
since they are not really a runtime thing; also, there are typically a
fixed small number of sets,maps impls (array, binary tree)

* 2015-12-30 module type errors

  - type of simple.E3 without last arg:
    - 

module E3 :
  functor
    (Earley_state : sig
                      module Symbol :
                        sig
                          type nt = Symbol.nt
                          type tm = Symbol.tm
                          type sym = Symbol.sym
                        end
                      module Item :
                        sig
                          module Symbol :
                            sig
                              type nt = Symbol.nt
                              type tm = Symbol.tm
                              type sym = Symbol.sym
                            end
                          type tm_item = Item.tm_item
                          type nt_item = Item.nt_item
                          type sym_item = Item.sym_item
                          type sym_list = Item.sym_list
                          type item = Item.item
                          type ops_t =
                            Item.ops_t = {
                            sym_case :
                              Symbol.sym ->
                              [ `NT of Symbol.nt | `TM of Symbol.tm ];
                            sym_of_tm : Symbol.tm -> Symbol.sym;
                            mk_tm_coord : Symbol.tm * int -> tm_item;
                            tm5 : tm_item -> Symbol.tm;
                            mk_sym_coord : Symbol.sym * int * int -> sym_item;
                            sym6 : sym_item -> Symbol.sym;
                            nt2 : nt_item -> Symbol.sym;
                            shift_a2_b2_c2 : nt_item -> nt_item;
                            b2_nil : nt_item -> bool;
                            a2 : nt_item -> sym_list;
                            hd_b2 : nt_item -> Symbol.sym;
                            mk_item :
                              [ `NTITM of nt_item | `TMITM of tm_item ] ->
                              item;
                            dest_item :
                              item ->
                              [ `NTITM of nt_item | `TMITM of tm_item ];
                            tm_dot_i9 : tm_item -> int;
                            sym_dot_i9 : sym_item -> int;
                            sym_dot_j9 : sym_item -> int;
                            nt_dot_i9 : nt_item -> int;
                            nt_dot_j9 : nt_item -> int;
                            with_j9 : nt_item -> int -> nt_item;
                          }
                          val ops : ops_t
                        end
                      module Sets :
                        sig
                          module Item :
                            sig
                              module Symbol :
                                sig
                                  type nt = Symbol.nt
                                  type tm = Symbol.tm
                                  type sym = Symbol.sym
                                end
                              type tm_item = Item.tm_item
                              type nt_item = Item.nt_item
                              type sym_item = Item.sym_item
                              type sym_list = Item.sym_list
                              type item = Item.item
                              type ops_t =
                                Item.ops_t = {
                                sym_case :
                                  Symbol.sym ->
                                  [ `NT of Symbol.nt | `TM of Symbol.tm ];
                                sym_of_tm : Symbol.tm -> Symbol.sym;
                                mk_tm_coord : Symbol.tm * int -> tm_item;
                                tm5 : tm_item -> Symbol.tm;
                                mk_sym_coord :
                                  Symbol.sym * int * int -> sym_item;
                                sym6 : sym_item -> Symbol.sym;
                                nt2 : nt_item -> Symbol.sym;
                                shift_a2_b2_c2 : nt_item -> nt_item;
                                b2_nil : nt_item -> bool;
                                a2 : nt_item -> sym_list;
                                hd_b2 : nt_item -> Symbol.sym;
                                mk_item :
                                  [ `NTITM of nt_item | `TMITM of tm_item ] ->
                                  item;
                                dest_item :
                                  item ->
                                  [ `NTITM of nt_item | `TMITM of tm_item ];
                                tm_dot_i9 : tm_item -> int;
                                sym_dot_i9 : sym_item -> int;
                                sym_dot_j9 : sym_item -> int;
                                nt_dot_i9 : nt_item -> int;
                                nt_dot_j9 : nt_item -> int;
                                with_j9 : nt_item -> int -> nt_item;
                              }
                              val ops : ops_t
                            end
                          module Set_todo_done :
                            sig
                              type t = Sets_maps.Sets.Set_todo_done.t
                              val std_empty : unit -> t
                              val std_add : Item.item -> t -> t
                              val std_mem : Item.item -> t -> bool
                            end
                        end
                      module Maps :
                        sig
                          module Symbol :
                            sig
                              type nt = Symbol.nt
                              type tm = Symbol.tm
                              type sym = Symbol.sym
                            end
                          module Item :
                            sig
                              module Symbol :
                                sig
                                  type nt = Symbol.nt
                                  type tm = Symbol.tm
                                  type sym = Symbol.sym
                                end
                              type tm_item = Item.tm_item
                              type nt_item = Item.nt_item
                              type sym_item = Item.sym_item
                              type sym_list = Item.sym_list
                              type item = Item.item
                              type ops_t =
                                Item.ops_t = {
                                sym_case :
                                  Symbol.sym ->
                                  [ `NT of Symbol.nt | `TM of Symbol.tm ];
                                sym_of_tm : Symbol.tm -> Symbol.sym;
                                mk_tm_coord : Symbol.tm * int -> tm_item;
                                tm5 : tm_item -> Symbol.tm;
                                mk_sym_coord :
                                  Symbol.sym * int * int -> sym_item;
                                sym6 : sym_item -> Symbol.sym;
                                nt2 : nt_item -> Symbol.sym;
                                shift_a2_b2_c2 : nt_item -> nt_item;
                                b2_nil : nt_item -> bool;
                                a2 : nt_item -> sym_list;
                                hd_b2 : nt_item -> Symbol.sym;
                                mk_item :
                                  [ `NTITM of nt_item | `TMITM of tm_item ] ->
                                  item;
                                dest_item :
                                  item ->
                                  [ `NTITM of nt_item | `TMITM of tm_item ];
                                tm_dot_i9 : tm_item -> int;
                                sym_dot_i9 : sym_item -> int;
                                sym_dot_j9 : sym_item -> int;
                                nt_dot_i9 : nt_item -> int;
                                nt_dot_j9 : nt_item -> int;
                                with_j9 : nt_item -> int -> nt_item;
                              }
                              val ops : ops_t
                            end
                          type mbk_key = int * Symbol.sym
                          type mbk_value = Item.nt_item
                          module Map_blocked_key :
                            sig
                              type t = Sets_maps.Maps.Map_blocked_key.t
                              val map_fold_cod :
                                mbk_key ->
                                (mbk_value -> 'b -> 'b) -> t -> 'b -> 'b
                              val map_empty : unit -> t
                              val map_add_cod :
                                mbk_key -> mbk_value -> t -> t
                              val map_cod_empty : mbk_key -> t -> bool
                            end
                          type mck_key = int * Symbol.sym
                          type mck_value = Item.sym_item
                          module Map_complete_key :
                            sig
                              type t = Sets_maps.Maps.Map_complete_key.t
                              val map_empty : unit -> t
                              val map_add_cod :
                                mck_key -> mck_value -> t -> t
                              val map_fold_cod :
                                mck_key ->
                                (mck_value -> 'b -> 'b) -> t -> 'b -> 'b
                            end
                          type mti_key = Symbol.tm * int
                          type mti_value = int
                          module Map_tm_int :
                            sig
                              type t = Sets_maps.Maps.Map_tm_int.t
                              val map_empty : unit -> t
                              val map_add_cod :
                                mti_key -> mti_value -> t -> t
                              val map_find_cod :
                                mti_key -> mti_value -> t -> bool
                            end
                          type mssii_key =
                              Item.sym_list * Symbol.sym * int * int
                          type mssii_value = int
                          module Map_sym_sym_int_int :
                            sig

XXX (arg sig to E3; type t should be abstract? but this is most specific type we can give and should match the impl)
                              type t = Sets_maps.Maps.Map_sym_sym_int_int.t
                              val map_empty : unit -> t
                              val map_add_cod :
                                mssii_key -> mssii_value -> t -> t
                              val mssii_elts_cod :
                                mssii_key -> t -> mssii_value list
                            end
                        end
                      type ty_loop2 = {
                        todo_done5 : Sets.Set_todo_done.t;
                        todo5 : Item.item list;
                        oracle5 : Maps.Map_sym_sym_int_int.t;
                        tmoracle5 : Maps.Map_tm_int.t;
                        blocked5 : Maps.Map_blocked_key.t;
                        complete5 : Maps.Map_complete_key.t;
                      }
                    end) ->
    sig
      module Symbol :
        sig type nt = Symbol.nt type tm = Symbol.tm type sym = Symbol.sym end
      module Item :
        sig
          module Symbol :
            sig
              type nt = Symbol.nt
              type tm = Symbol.tm
              type sym = Symbol.sym
            end
          type tm_item = Item.tm_item
          type nt_item = Item.nt_item
          type sym_item = Item.sym_item
          type sym_list = Item.sym_list
          type item = Item.item
          type ops_t =
            Item.ops_t = {
            sym_case : Symbol.sym -> [ `NT of Symbol.nt | `TM of Symbol.tm ];
            sym_of_tm : Symbol.tm -> Symbol.sym;
            mk_tm_coord : Symbol.tm * int -> tm_item;
            tm5 : tm_item -> Symbol.tm;
            mk_sym_coord : Symbol.sym * int * int -> sym_item;
            sym6 : sym_item -> Symbol.sym;
            nt2 : nt_item -> Symbol.sym;
            shift_a2_b2_c2 : nt_item -> nt_item;
            b2_nil : nt_item -> bool;
            a2 : nt_item -> sym_list;
            hd_b2 : nt_item -> Symbol.sym;
            mk_item : [ `NTITM of nt_item | `TMITM of tm_item ] -> item;
            dest_item : item -> [ `NTITM of nt_item | `TMITM of tm_item ];
            tm_dot_i9 : tm_item -> int;
            sym_dot_i9 : sym_item -> int;
            sym_dot_j9 : sym_item -> int;
            nt_dot_i9 : nt_item -> int;
            nt_dot_j9 : nt_item -> int;
            with_j9 : nt_item -> int -> nt_item;
          }
          val ops : ops_t
        end
      module Sets :
        sig
          module Item :
            sig
              module Symbol :
                sig
                  type nt = Symbol.nt
                  type tm = Symbol.tm
                  type sym = Symbol.sym
                end
              type tm_item = Item.tm_item
              type nt_item = Item.nt_item
              type sym_item = Item.sym_item
              type sym_list = Item.sym_list
              type item = Item.item
              type ops_t =
                Item.ops_t = {
                sym_case :
                  Symbol.sym -> [ `NT of Symbol.nt | `TM of Symbol.tm ];
                sym_of_tm : Symbol.tm -> Symbol.sym;
                mk_tm_coord : Symbol.tm * int -> tm_item;
                tm5 : tm_item -> Symbol.tm;
                mk_sym_coord : Symbol.sym * int * int -> sym_item;
                sym6 : sym_item -> Symbol.sym;
                nt2 : nt_item -> Symbol.sym;
                shift_a2_b2_c2 : nt_item -> nt_item;
                b2_nil : nt_item -> bool;
                a2 : nt_item -> sym_list;
                hd_b2 : nt_item -> Symbol.sym;
                mk_item : [ `NTITM of nt_item | `TMITM of tm_item ] -> item;
                dest_item : item -> [ `NTITM of nt_item | `TMITM of tm_item ];
                tm_dot_i9 : tm_item -> int;
                sym_dot_i9 : sym_item -> int;
                sym_dot_j9 : sym_item -> int;
                nt_dot_i9 : nt_item -> int;
                nt_dot_j9 : nt_item -> int;
                with_j9 : nt_item -> int -> nt_item;
              }
              val ops : ops_t
            end
          module Set_todo_done :
            sig
              type t = Sets_maps.Sets.Set_todo_done.t
              val std_empty : unit -> t
              val std_add : Item.item -> t -> t
              val std_mem : Item.item -> t -> bool
            end
        end
      module Maps :
        sig
          module Symbol :
            sig
              type nt = Symbol.nt
              type tm = Symbol.tm
              type sym = Symbol.sym
            end
          module Item :
            sig
              module Symbol :
                sig
                  type nt = Symbol.nt
                  type tm = Symbol.tm
                  type sym = Symbol.sym
                end
              type tm_item = Item.tm_item
              type nt_item = Item.nt_item
              type sym_item = Item.sym_item
              type sym_list = Item.sym_list
              type item = Item.item
              type ops_t =
                Item.ops_t = {
                sym_case :
                  Symbol.sym -> [ `NT of Symbol.nt | `TM of Symbol.tm ];
                sym_of_tm : Symbol.tm -> Symbol.sym;
                mk_tm_coord : Symbol.tm * int -> tm_item;
                tm5 : tm_item -> Symbol.tm;
                mk_sym_coord : Symbol.sym * int * int -> sym_item;
                sym6 : sym_item -> Symbol.sym;
                nt2 : nt_item -> Symbol.sym;
                shift_a2_b2_c2 : nt_item -> nt_item;
                b2_nil : nt_item -> bool;
                a2 : nt_item -> sym_list;
                hd_b2 : nt_item -> Symbol.sym;
                mk_item : [ `NTITM of nt_item | `TMITM of tm_item ] -> item;
                dest_item : item -> [ `NTITM of nt_item | `TMITM of tm_item ];
                tm_dot_i9 : tm_item -> int;
                sym_dot_i9 : sym_item -> int;
                sym_dot_j9 : sym_item -> int;
                nt_dot_i9 : nt_item -> int;
                nt_dot_j9 : nt_item -> int;
                with_j9 : nt_item -> int -> nt_item;
              }
              val ops : ops_t
            end
          type mbk_key = int * Symbol.sym
          type mbk_value = Item.nt_item
          module Map_blocked_key :
            sig
              type t = Sets_maps.Maps.Map_blocked_key.t
              val map_fold_cod :
                mbk_key -> (mbk_value -> 'b -> 'b) -> t -> 'b -> 'b
              val map_empty : unit -> t
              val map_add_cod : mbk_key -> mbk_value -> t -> t
              val map_cod_empty : mbk_key -> t -> bool
            end
          type mck_key = int * Symbol.sym
          type mck_value = Item.sym_item
          module Map_complete_key :
            sig
              type t = Sets_maps.Maps.Map_complete_key.t
              val map_empty : unit -> t
              val map_add_cod : mck_key -> mck_value -> t -> t
              val map_fold_cod :
                mck_key -> (mck_value -> 'b -> 'b) -> t -> 'b -> 'b
            end
          type mti_key = Symbol.tm * int
          type mti_value = int
          module Map_tm_int :
            sig
              type t = Sets_maps.Maps.Map_tm_int.t
              val map_empty : unit -> t
              val map_add_cod : mti_key -> mti_value -> t -> t
              val map_find_cod : mti_key -> mti_value -> t -> bool
            end
          type mssii_key = Item.sym_list * Symbol.sym * int * int
          type mssii_value = int
          module Map_sym_sym_int_int :
            sig
              type t = Sets_maps.Maps.Map_sym_sym_int_int.t
              val map_empty : unit -> t
              val map_add_cod : mssii_key -> mssii_value -> t -> t
              val mssii_elts_cod : mssii_key -> t -> mssii_value list
            end
        end
      val update_oracle :
        Maps.Map_sym_sym_int_int.t ->
        Item.nt_item * int -> Maps.Map_sym_sym_int_int.t
      val update_tmoracle :
        Maps.Map_tm_int.t -> Symbol.tm * int * int -> Maps.Map_tm_int.t
      val todo_is_empty : Earley_state.ty_loop2 -> bool
      val add_todo :
        Earley_state.ty_loop2 -> Sets.Item.item -> Earley_state.ty_loop2
      val pop_todo :
        Earley_state.ty_loop2 ->
        Earley_state.ty_loop2 * Earley_state.Item.item
      val cut :
        Item.nt_item ->
        Item.sym_item -> Earley_state.ty_loop2 -> Earley_state.ty_loop2
      val step :
        Ctxt.ctxt_t -> Earley_state.ty_loop2 -> Earley_state.ty_loop2
      val earley :
        Ctxt.ctxt_t -> Earley_state.ty_loop2 -> Earley_state.ty_loop2
    end


error msg:



error

-*- mode: compilation; default-directory: "/tmp/l/github/e3/src/" -*-
Compilation started at Wed Dec 30 11:33:16

make -k -C /tmp/l/github/e3/
make: Entering directory `/mnt/sdb1/tom/github/e3'
ocamlbuild -I src -cflag -w -cflag -8 core_types.cmo map_set_types.cmo core.cmo simple.cmo
/home/tr61/.opam/4.02.3/bin/ocamldep.opt -modules src/simple.ml > src/simple.ml.depends
/home/tr61/.opam/4.02.3/bin/ocamlc.opt -c -w -8 -annot -bin-annot -I src -o src/simple.cmo src/simple.ml
+ /home/tr61/.opam/4.02.3/bin/ocamlc.opt -c -w -8 -annot -bin-annot -I src -o src/simple.cmo src/simple.ml
File "src/simple.ml", line 261, characters 83-95:
Error: Signature mismatch:
       ...
       In module Maps.Map_sym_sym_int_int:
       Type declarations do not match:
         type t = Map_set_types.Default_map_impl(Key_ord)(Sets_maps.I1).t
       is not included in
         type t = Sets_maps.Maps.Map_sym_sym_int_int.t
Command exited with code 2.
make: *** [all] Error 10
make: Leaving directory `/mnt/sdb1/tom/github/e3'

Compilation exited abnormally with code 2 at Wed Dec 30 11:33:17

* 2015-12-30 order of fixing

  - we should provide a simple implementation of symbols, using a
    datatype (not just ints)
    - for p4 etc we also need to allow the user to define symbols and
      nt_item type, but we don't want the user to have to provide
      implementations of sets and map types; so somehow the user
      should provide the necessary info to allow construction of the
      set/map impls
    - p4 currently does this using gensym to tag symbols, lists of
      symbols, and items
  - the nt_items_for_nt could be altered to provide a list of symbols
    rather than nt_item; this would allow to hide the nt_item type,
    but this may not be what is wanted (eg p4 client needs to maintain
    an explicit nt_item type)
  - we should provide (ocaml std map, hashtable, array)
    implementations which the user can choose; we probably need
    orderings on symbols, and items (nt_item, sym_item, item)
  - need a default symbol impl; a default item impl (given symbol);
    and several sets/maps impls (given symbol, item, and some
    additional ordering/enumeration info)
* 2016-01-08 factorizing out the impl of sets and maps from simpl and hashtbl
* 2016-01-08 timings on pc1177


tr61@pc1177:/tmp/l/github/e3$ ./examples.native 
Start example 833 ......stop in 0.790363 seconds
Start example u5o ......stop in 6.772121 seconds
Start example 86f ......stop in 0.296937 seconds
Start example 17y ......stop in 2.253628 seconds
* 2016-01-14 array implementation

  - we want to work exclusively with integers
  - hashkey_t is misnamed; fixed
  - we need a different representation of items which takes the rhs
    into account; also shift should increment the index to avoid
    recalculating the index every time
    - an alternative is to tag every subrhs; this is probably better;
      also need a tag for the empty rhs
    - another alternative is to use an abstract type for items, which
      is actually int, and index into an array for the ops
      - this could be made general by assuming a function to map
        nt_item to int, and feeding in knowledge of the items at the
        start to enable precomputation; would have to feed in all
        nt_items (disregarding their coords); this in turn assumes
        that we are really abstracting over sym lists that can appear
      - note that we also have to override equals for sym_list
      - in fact, we are really thinking of abstracting over the *pair*
        of sym lists in nt_item
        - and then defining shift,b2_nil,a2,hd_b2
    - might be worth introducing another type "rev_sym_list_t"? just
      to makeit clear that things are stored in reverse?
      - 
  - the old e3_array looks like it just optimizes set_todo_done by
    making a 2d array and indexing into this (with a set of nt_item as
    before); this might have similar performance to a nested
    hashtable, with the first key being (i,j); worth checking the
    hashtable performance with this change?

before:

tr61@pc1177:/tmp/l/github/e3$ ./examples.native 
Start example 833 ......stop in 0.798566 seconds
Start example u5o ......stop in 6.851075 seconds
Start example 86f ......stop in 0.297224 seconds
Start example 17y ......stop in 2.32618 seconds

after (with change to maps)
tr61@pc1177:/tmp/l/github/e3$ ./examples.native 
Start example 833 ......stop in 0.799895 seconds
Start example u5o ......stop in 6.85153 seconds
Start example 86f ......stop in 0.300005 seconds
Start example 17y ......stop in 2.359839 seconds

so no change (slightly worse)

what about doing a similar thing for sets? no real change either

  - so if we want better performance we should allocate the array and
    use i,j to index into it
  - but from comments in example.ml, it appears that the array was not
    that much faster than the pure hashtable anyway
  - so these changes are fruitless!


* 2016-02-04 timings on pc1177 with single insert into std, and boolean to indicate whether item was already present

Start example 833 ......stop in 0.691734 seconds
Start example u5o ......stop in 6.021071 seconds
Start example 86f ......stop in 0.239377 seconds
Start example 17y ......stop in 1.873853 seconds

* 2016-02-06 thoughts on further optimization

  - need to get more info on the frequency of various operations, and
    their cost
  -


* 2016-02-06 functional/imperative impl for maps to sets

  - we have a map 'a -> 'b set
  - typically we are given an a, and want the 'b set pulled out, so we
    don't have to keep looking it up in the map
  - at some point later, we want to push the updated 'b set back into
    the map; for imperative impls this is redundant because we are
    mutating the 'b set in place
  - what is needed is a guarantee that the a -> bs entry in the map is
    unchanged while we alter bs; then an imperative impl doesn't have
    to update the map after updating bs
  - this isn't just a lookup and a later replace, it is a "lookup and
    lock", and later "replace and free".
  - for us, this lock could lock the entire map
  - thus, one might propose that ('a,'b) map = m_t support an
    operation lookup: m_t -> m_t' * 'b, and free: m_t' * 'b' -> m_t
    where m_t' is the "context" of the map
  - this is all rather complicated
  - essentially we are trying to avoid a map update when using an
    imperative impl; one way to do this is to record the map.find
    (k,v) and when we update the map, check physical equality of the
    (k,v') (in which case, don't bother with the update)
  - this is all really about parameterization, fixed vars etc
  - the other thing we may want is to make every set_add indicate
    whether the value was already present
